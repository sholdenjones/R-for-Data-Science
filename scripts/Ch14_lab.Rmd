---
title: "Ch14_lab"
author: "Holden Jones"
date: '2022-09-28'
output: html_document
---

# Strings


--------------------------------------------------------------------------------
# 14.1 Introduction

intro to string manipulation. focus is on regular expressions
regexps are concise language for describing patterns in strings - they look crazy
  at first!
  
## 14.1.1 Prerequisites
```{r}
library(tidyverse)
```


--------------------------------------------------------------------------------
# 14.2 String basics

can create strings with "" or '', usually do "" unless need multiple quotes
```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
```

have to be really specific with quotes within strings, and backslashes

use writeLines() to see the actual string contents

"\n" for newline and "\n" for tab

## 14.2.1 String length

use str_length
```{r}
str_length(c("a", "R for data science", NA))
```

## 14.2.2 Combining strings

use str_c
```{r}
str_c("x", "y")

str_c("x", "y", "z")
```

missing values contagious, use str_replace_na(x) if want to print as NA

objects of length 0 silently dropped, useful with if
```{r}
name <- "Holden"
time_of_day <- "night"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

collapse to make a vector a single string
```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```

## 14.2.3 Subsetting strings

str_sub() to extract parts of a string, start and end arguments
```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
str_sub(x, -3, -1)
```

doesn't fail if string is too short

## 14.2.4 Locales

str_to_lower() and str_to_upper() to make uper or lower case
use locale, b/c some places have different cap rules ex. Turkey

sorting also affected by locale
str_sort() and str_order() take additional locale argument:
```{r}
x <- c("apple", "eggplant", "banana")

str_sort(x, locale = "en")  # English

str_sort(x, locale = "haw") # Hawaiian
# why would hawaiian have different sorting? vowels first?
```

## 14.2.5 Exercises

1. In code that doesn’t use stringr, you’ll often see paste()
and paste0(). What’s the difference between the two functions?
What stringr function are they equivalent to? How do the
functions differ in their handling of NA?
*paste converts its arguments to character strings and seperates by sep argument, space as default. paste0 is more effeicient and assumes that sep = "" ie no spacing*
*str_c is closer in behavior to paste0*
*but they do handle NAs differently, for str_c if one is NA the whole thing is!*
```{r}
paste("base", "ball")

paste0("base", "ball")

str_c("base", "ball")

str_c("foo", NA)

paste("foo", NA)

paste0("foo", NA)
```

2. In your own words, describe the difference between the 
sep and collapse arguments to str_c().
*sep asks how to separate each ind string from the one before and after the previous / next. Collapse asks should these all become one string?*
```{r}
str_c("base", "ball", sep = "", collapse = NULL)
str_c("base", "ball", sep = "_", collapse = NULL)

str_c("base", "ball", collapse = "")
str_c("base", "ball", sep = "  ")

str_c(letters, collapse = "")
str_c(letters, sep = "")
```

3. Use str_length() and str_sub() to extract the middle
character from a string. What will you do if the string has 
an even number of characters?
```{r}
x <- "letsgomets"

str_sub(x,
        str_length(x) / 2,
        str_length(x) / 2
)

# from answers:
x <- c("lets", "go", "mets")
L <- str_length(x)
m <- ceiling(L / 2)
str_sub(x, m, m)

```

4. What does str_wrap() do? When might you want to use it?
*it wraps strings into nicely formatted paragraphs*
*maybe if making a markdown? or something that needs to be read*

5. What does str_trim() do? What’s the opposite of str_trim()?
*str_trim() removes whitespace from start and end of string*
*str_pad() is opposite and adds whitespace*

6. Write a function that turns (e.g.) a vector c("a", "b",
"c") into the string a, b, and c. Think carefully about what
it should do if given a vector of length 0, 1, or 2.
*string - just a character variable that contains one or more characters*
*character vector is a set of strings stored as a single object*
*lmao just using the answer sheet for this one:*
```{r}
str_commasep <- function(x, delim = ",") {
  n <- length(x)
  if (n == 0) {
    ""
  } else if (n == 1) {
    x
  } else if (n == 2) {
    # no comma before and when n == 2
    str_c(x[[1]], "and", x[[2]], sep = " ")
  } else {
    # commas after all n - 1 elements
    not_last <- str_c(x[seq_len(n - 1)], delim)
    # prepend "and" to the last element
    last <- str_c("and", x[[n]], sep = " ")
    # combine parts with spaces
    str_c(c(not_last, last), collapse = " ")
  }
}

str_commasep("")

str_commasep("a")

str_commasep(c("a", "b"))

str_commasep(c("a", "b", "c"))

str_commasep(c("a", "b", "c", "d"))
```


--------------------------------------------------------------------------------
# 14.3 Matching patterns with regular expressions

regexps allow describing of patterns in strings
use str_view() and str_view_all()
- take char vector and reg exp and show how they match
- this is about pattern matching

## 14.3.1 Basic matches
```{r}
x <- c("apple", "banana", "pear")

# simplest, match exact string
str_view(x, "an")

# add ., matches any char (except a newline)
str_view(x, ".a.")
```

but how do we match "."?
- use escape with backslash "\", but that also used in strings
- so use "\\."
```{r}
# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)
#> \.

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
```

to match a literal \ you need to write "\\\\" — you need four backslashes to match one!
```{r}
x <- "a\\b"
writeLines(x)

str_view(x, "\\\\")
```

In this book, I’ll write regular expression as \. and strings that represent the regular expression as "\\."

## 14.3.1.1 Exercises

1. Explain why each of these strings don’t match a \: "\", "\\", "\\\".
*need 4 \\\\ to match a \, regexp to escape \\, \ needed to escape the string made for the regexp*

2. How would you match the sequence "'\?
```{r}
str_view("\"'\\", "\"'\\\\", match = TRUE)
```

3. What patterns will the regular expression \..\..\.. match? How would you represent it as a string?
*anytime a "." is followed by any character, repeated three times*
```{r}
str_view(c(".a.b.c", ".a.b", "....."), c("\\..\\..\\.."), match = TRUE)
```

## 14.3.2 Anchors

often useful to anchor the regexp so it matches from start or end of string, can use:
^ to match start of string
$ to match end of string
use both to only match complete string
```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")

x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

str_view(x, "^apple$")
```

## 14.3.2.1 Exercises

1. How would you match the literal string "$^$"?
*this makes no sense at all lol*
```{r}
str_view(c("$^$", "ab$^$sfas"), "^\\$\\^\\$$", match = TRUE)

# ok so the \\ are needed to escape, we need 2 b/ween each char
str_view(c("$^^$", "ab$^^$sfas"), "^\\$\\^\\^\\$$", match = TRUE)
```

2. Given the corpus of common words in stringr::words, create regular expressions that find all words that:
- Start with “y”
```{r}
str_view(words, "^y", match = TRUE)
```
- End with “x”
```{r}
str_view(words, "x$", match = TRUE)
```
- Are exactly three letters long. (Don’t cheat by using str_length()!)
```{r}
str_view(words, "^...$", match = TRUE)
```
- Have seven letters or more.
```{r}
str_view(words, ".......", match = TRUE)
```
- Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words.

## 14.3.3 Character classes and alternatives

some characters can match several other things
```{r}
# Look for a literal character that normally has special meaning in a regex
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")

str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")

str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")

# use | for precedence
str_view(c("grey", "gray"), "gr(e|a)y")
```

# 14.3.3.1 Exercises

1. Create regular expressions to find all words that:
- Start with a vowel.
```{r}
str_subset(words, "^(a|e|i|o|u)")
```
- That only contain consonants. (Hint: thinking about matching “not”-vowels.)
```{r}
str_subset(words, "[aeiou]", negate=TRUE)
```
- End with ed, but not with eed.
```{r}
str_subset(words, "[^e]ed$")
```
- End with ing or ise.
```{r}
str_subset(words, "ing$|ise$")
```

2. Empirically verify the rule “i before e except after c”.
```{r}
str_subset(words, "cie")
```

3. Is “q” always followed by a “u”?
```{r}
str_subset(words, "q.")
```

4. Write a regular expression that matches a word if it’s probably written in
British English, not American English.
```{r}
str_subset(words, "ou")

str_subset(words, "ou|ise$|ae|oe|yse$")
```

5. Create a regular expression that will match telephone numbers as commonly
written in your country.
```{r}
# from answers:
x <- c("123-456-7890", "(123)456-7890", "(123) 456-7890", "1235-2351")
str_view(x, "\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d")
```

## 14.3.4 Repetition

## RESUME HERE

