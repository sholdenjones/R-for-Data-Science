---
title: "Ch_13_lab"
author: "Holden Jones"
date: '2022-09-13'
output: html_document
---

# Relational Data


--------------------------------------------------------------------------------
# 13.1 Introduction

multiple tables of data are called relational data - b/c the realtions are 
important

need verbs that work with pairs of tables, 3 families of verbs for this:
- mutating joins - add new variables to one df from matching obs in another
- filtering joins - filter obs from one df based on whether they match obs in
                    other table
- set operations - treat obs as if they were set elements

relational data most often found in a relational database management system
or RDBMS - SQL usually used for this!

generally, dplyr a little easier to use than SQL but more focused on data
analysis

## 13.1.1 Prerequisites
```{r}
library(tidyverse)
library(nycflights13)

# from answers
library("viridis")
```


--------------------------------------------------------------------------------
# 13.2 nycflights13

4 tibbles related to the flights table
- airlines
- airports
- planes
- weather

can show relationship between tables with a drawing!
practice with my ranas data

## 13.2.1 Exercises

1. Imagine you wanted to draw (approximately) the route each plane flies from 
its origin to its destination. What variables would you need? What tables 
would you need to combine?
*need location of origin and dest airports, the planes that fly between them, so combine flights and airports*
```{r}
# from answers
flights_latlon <- flights %>%
  inner_join(select(airports, origin = faa, origin_lat = lat, origin_lon = lon),
    by = "origin"
  ) %>%
  inner_join(select(airports, dest = faa, dest_lat = lat, dest_lon = lon),
    by = "dest"
  )

flights_latlon %>%
  slice(1:100) %>%
  ggplot(aes(
    x = origin_lon, xend = dest_lon,
    y = origin_lat, yend = dest_lat
  )) +
  borders("state") +
  geom_segment(arrow = arrow(length = unit(0.1, "cm"))) +
  coord_quickmap() +
  labs(y = "Latitude", x = "Longitude")
```

2. I forgot to draw the relationship between weather and airports. What is 
the relationship and how should it appear in the diagram?
*they connect via airport full name and weather origin code - so would need to fix these so that they overlap before joining / binding*

3. weather only contains information for the origin (NYC) airports. If it
contained weather records for all airports in the USA, what additional relation
would it define with flights?
*if it also had weather data for all US airports it would link to dest as well*

4. We know that some days of the year are “special”, and fewer people than usual
fly on them. How might you represent that data as a data frame? What would be 
the primary keys of that table? How would it connect to the existing tables?
*hmm, for special days, would want several weather columns from weather and year month day from flights, and number of flights from a flights group_by*


--------------------------------------------------------------------------------
# 13.3 Keys

variables used to connect tables - keys!
- primary - uniquely identifies an observation in its own table
- foreign - uniquely identifies an observation in another table

a variable can be both at the same time

identify primary keys first, good practice to count() them
```{r}
planes %>% 
  count(tailnum) %>% 
  filter(n > 1)

weather %>% 
  count(year, month, day, hour, origin) %>% 
  filter(n > 1)
```

sometimes a table won't have an explicit primary key
```{r}
flights %>% 
  count(year, month, day, tailnum) %>% 
  filter(n > 1)
# planes can fly more than once per day!
```

if a table lacks a key, can add one with mutate() and row_number(), this is a
surrogate key

## 13.3.1 Exercises

1. Add a surrogate key to flights.
```{r}
flights <- flights %>%
  mutate(flight = row_number())

# check that key works here:
flights %>%
  count(flight) %>%
  filter(n > 1)
```

2. Identify the keys in the following datasets
Lahman::Batting,
babynames::babynames
nasaweather::atmos
fueleconomy::vehicles
ggplot2::diamonds
```{r}
#
library(Lahman)
Batting %>%
  count(playerID, yearID, stint) %>%
  filter(n > 1)

library(babynames)
babynames %>%
  count(year, sex, name) %>%
  filter(n >1)

nasaweather::atmos %>%
  count(lat, long, year, month) %>%
  filter(n > 1)

fueleconomy::vehicles %>%
  count(id) %>%
  filter(n > 1)

library(ggplot2)
diamonds %>%
  count(carat, price, depth, table, x, y, z) %>%
  filter(n > 1)
# there is no primary key! so lets make a surrogate

diamonds %>%
  mutate(row = row_number()) %>% # this will be surrogate
  count(row) %>%
  filter(n > 1)
```

3. Draw a diagram illustrating the connections between the
Batting, People, and Salaries tables in the Lahman package. 
Draw another diagram that shows the relationship between People,
Managers, AwardsManagers. How would you characterise the
relationship between the Batting, Pitching, and Fielding tables?
*Batting - People linked by playerID*
*Batting - Salaries linked by playerID, teamID, yearID*
*People - Salaries linked by playerID*

*People - Managers linked by playerID*
*People - AwardsManagers linked by playerID*
*Managers - AwardsManagers linked by playerID, yearID*

*the batting pitching and fielding tables seem pretty easily transferrable - all linked to each other by playerID, yearID, stint, but fielding also needs POS!!!!*


--------------------------------------------------------------------------------
# 13.4 Mutating joins

mutating join - combine variables from two tables
work with smaller dataframe to make easier
```{r}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)

flights2 %>%
  select(-origin, -dest) %>% 
  left_join(airlines, by = "carrier")
# brings in all of airlines df - so adds name column
```

could also do this with R's base subsetting, but mutate_join is cleaner

## 13.4.1 Understanding joins

key variable used to match rows between tables, the value column(s) come along
for the ride
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

## 13.4.2 Inner join

simplest type of join - pairs matched whenever their keys are equal
most important property is that unmatched rows are not included in resulting df
- usually not appropriate for analysis b/c too easy to lose observations

The output of an inner join is a new data frame that contains the key, the x 
values, and the y values. We use by to tell dplyr which variable is the key:
```{r}
x %>% 
  inner_join(y, by = "key")
```

## 13.4.3 Outer joins

outer join keeps observations that apear in at least one of the tables, 3 types:
- left join keeps all obs in x
- right join keeps all obs in y
- full join keeps all obs in x and y
these joins add an additional "virtual" obs that always matches if no other does

*left join should be default join - preserves original obs even without a match*

but sometimes keys don't uniquely identify an obs...

## 13.4.4 Duplicate keys

so far all have assumed that keys are unique, but this not always the case,
2 possibilities:

1. one table has duplicate keys - useful when want to add in additional info as 
    there typically is a one to many relationship, so key can be primary in one 
    table and foreign in the other
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
left_join(x, y, by = "key")
```

2. both tables have duplicate keys - usually an error b/c in neither do keys
    uniquely ID an observation, joining gets all possible combos, Cartesian product
*duplicate keys are super bad!!!*
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)
left_join(x, y, by = "key")
```

## 13.4.5 Defining the key columns

by="key", can use other values for by to connect tables in other ways:
- default is by = NULL, uses all vars that appear in both tables - a
    natural join
- char vector, by = "x" - like a natural join but uses only some of common vars
- named char vector, by = c("a" = "b"). matches variable a in table x to var b
    in table y, variables from x will be used in output
```{r}
flights2 %>% 
  left_join(airports, c("dest" = "faa"))
```

## 13.4.6 Exercises

1. Compute the average delay by destination, then join on the airports data frame 
so you can show the spatial distribution of delays. Here’s an easy way to draw a 
map of the United States:
```{r}
avg_delay_dest <- flights %>%
  group_by(dest) %>%
  summarise(avg_delay = mean(arr_delay, na.rm = TRUE)) %>%
  inner_join(airports, by = c(dest = "faa"))

avg_delay_dest %>%
  ggplot(aes(lon, lat)) +
  borders("state") +
  geom_point(aes(color = avg_delay)) +
  coord_quickmap()
```

2. Add the location of the origin and destination (i.e. the lat and lon) to flights.
definitely can make this cleaner! I bet someone can do this with 3 lines
```{r}
flights_loc <- flights %>%
  left_join(airports, c("dest" = "faa")) %>%
  mutate(dest_lat = lat,
         dest_lon = lon) %>%
  select(-c("name", "alt", "tz", "dst", "tzone","lat", "lon")) %>%
  left_join(airports, c("origin" = "faa")) %>%
  mutate(origin_lat = lat,
         origin_lon = lon) %>%
  select(-c("name", "alt", "tz", "dst", "tzone", "lat", "lon"))
```

3. Is there a relationship between the age of a plane and its delays?

##RESUME HERE



